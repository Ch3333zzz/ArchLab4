# Лабораторная работа №4
    Выполнил: Козьяков Арсений Дмитриевич (P3314)
    Преподаватель: Пенской Александр Владимирович
    Вариант:  lisp | acc | neum | hw | tick | binary | trap | mem | pstr | prob2 | superscalar
# Содержание
# Язык программирования
## Синтаксис
    <program>      ::= <expr>*
    
    <expr>         ::= <integer>
                     | <string>
                     | <identifier>
                     | <list-expr>
    
    <list-expr>    ::= "(" <operator> <expr>* ")"
                     | "(" "if" <expr> <expr> <expr>? ")"
                     | "(" "while" <expr> <expr>* ")"
                     | "(" "setq" <identifier> <expr> ")"
                     | "(" "defun" <identifier> "(" <identifier>* ")" <expr>* ")"
                     | "(" "progn" <expr>* ")"
                     | "(" "call" <identifier> <expr>* ")"     ; но любой (f a b) автоматически превращается в (call f a b)
                     | "(" "push" <expr>? ")"
                     | "(" "pop" <identifier>? ")"
                     | "(" "set-interrupt-vector" <identifier> ")"
                     | "(" "ei" ")"
                     | "(" "di" ")"
                     | "(" "read" ")"
                     | "(" "print" <expr> ")"
                     | "(" "out" <expr> ")"
                     | "(" "halt" ")"
                     | "(" "return" <expr>? ")"
                     | "(" ")"     ; пустой список допустим
    
    <operator>     ::= "+" | "-" | "*" | "/"
                     | "=" | "!=" | "<" | "<=" | ">" | ">="
                     | any <identifier>
    
    <integer>      ::= целочисленная константа
    <string>       ::= '"' последовательность символов'"'
    <identifier>   ::= любой непустой токен, не являющийся служебным выражением/числом/строкой
## Семантика
  **Стратегия вычисления**: строгая (eager) — перед применением операции сначала вычисляются все её операнды слева направо. \n
  
  **Нотация**: префиксная, т.е. форма (function a b ...) означает вызов function с аргументами a, b, ...
  
  **Типизация**: неявная.
  
  **Виды литералов**:
  
    - Знаковые 32х битные числа
    
    - Строки (pstr)
    
  **Операции**:
  
    - Арифметические операции: (+, -, *, /)
    
    - Операции сравнения: (>, >=, =, !=, <, <=)
    
    - (print arg): печатает значение ACC (если передан аргумент, он загружается в ACC и печатается) (print всегда печатает символы)
          если ACC указывает на pstr (length-prefixed string в пуле строк), то печатается строка символов;
          
    - (read arg): читает слово из MMIO_IN и возвращает его в аккумулятор
    
    - (out arg): выводит слово из аккумулятора в MMIO_OUT (печатает младший байт ACC)
    
    - (alloc n): выделить n слов в куче
    
    - (aset base idx val): записать val в MEM[base + idx] (для работы с массивами).
    
    - (aget base idx) — прочитать MEM[base + idx] в ACC (для работы с массивами).
    
    - (defun function_name (args) <function body>) - определить функцию с именем function_name, с агрументами args и телом function body
    
    - (setq var val) : объявить глобальную переменную с именем var и значением val
    
    - (if <cond> <then-expr> <else-expr>?): 
        Вычисляется выражение <cond>. Ненулевое значение считается true, ноль — false,
        Если <cond> ложно и есть <else-expr> — выполняется <else-expr> (его результат в ACC).
        Если <cond> ложно и <else-expr> отсутствует — if не выполняет ветвь.
        
    - (while <cond> <body-expr1> <body-expr2> ...)
    
        Каждую итерацию вычисляется <cond>. Если он ненулевой — выполняется тело цикла (последовательность выражений). После тела повторяется проверка.
        Если <cond> равен 0 при проверке перед первой итерацией — тело не выполняется.
        Возвращаемое значение while в ACC: если цикл не выполнен ни разу — ACC будет равен значению cond (обычно 0); если цикл выполнялся — ACC будет содержать                результат последнего выражения, которое было выполнено в теле (результат последней команды тела).
        
    - (progn <expr1> <expr2> ... <exprN>)
        progn вычисляет выражения слева направо.
        Результат progn — значение последнего выражения exprN, помещённое в ACC.
        Если progn пуст (нет выражений) — ACC не изменяется.
        
    - (return): 
        Если return встречается внутри тела функции (компилятор знает, что self.current_epilogue определён), то:
        компилируется expr (если есть) — результат в ACC,
        компилятор ставит JMP на заранее созданную метку эпилога функции (current_epilogue).
        Таким образом возврат идёт через общий эпилог, где выполняется LEAVE + RET. Это гарантирует корректное восстановление рамки стека.
        Если return используется не в функции (в глобальном контексте), current_epilogue == None и компилятор просто эмитит RET. В глобальном случае RET приведёт к            завершению исполнения.
        
    Примечание:
    Пример работы out и print:
    (print 65)    ;; выведет символы '6' '5' (печатает "65")
    (out 65)      ;; выведет один байт с кодом 65 -> 'A'
# Организация памяти
# Система команд
# Транслятор
# Модель процессора
# Тестирование
  
    
